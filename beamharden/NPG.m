classdef NPG < handle
    methods(Static)
        function out = main(Phi,Phit,Psi,Psit,y,xInit,opt)
            opt.continuation=false; opt.alphaStep='FISTA_ADMM_NNL1';
            out=lasso(Phi,Phit,Psi,Psit,y,xInit,opt);
        end
        function out = PG(Phi,Phit,Psi,Psit,y,xInit,opt)
            opt.continuation=false; opt.alphaStep='FISTA_ADMM_NNL1'; opt.adaptiveStep=false;
            out=lasso(Phi,Phit,Psi,Psit,y,xInit,opt);
        end
        function out = NPGc(Phi,Phit,Psi,Psit,y,xInit,opt)
            opt.continuation=true; opt.alphaStep='FISTA_ADMM_NNL1';
            out=lasso(Phi,Phit,Psi,Psit,y,xInit,opt);
        end
        function out = NPGs(Phi,Phit,Psi,Psit,y,xInit,opt)
            opt.continuation=false; opt.alphaStep='FISTA_L1';
            out=lasso(Phi,Phit,Psi,Psit,y,xInit,opt);
        end
        function out = FISTA(Phi,Phit,Psi,Psit,y,xInit,opt)
            opt.continuation=false; opt.alphaStep='FISTA_L1'; opt.adaptiveStep=false;
            % to call FISTA, user need to specify the choice for the initial step size to be either 'fixed' or 'BB'
            % opt.initStep='fixed'; % 'BB'; %
            out=lasso(Phi,Phit,Psi,Psit,y,xInit,opt);
        end
        function out = FPCas(Phi,Phit,Psi,Psit,y,xInit,opt)
            A = @(xx) Phi(Psi(xx)); At = @(yy) Psit(Phit(yy));
            AO=A_operator(A,At);
            option.x0=Psit(xInit);
            option.mxitr=opt.maxItr;
            option.gtol = 1e-20; option.gtol_scale_x = opt.thresh;
            [s, out] = FPC_AS_mod(length(option.x0),AO,y,opt.u,[],option);
            out.alpha = Psi(s);
            out.fVal=[0.5*sqrNorm(Phi(out.alpha)-y);...
                sqrNorm(out.alpha.*(out.alpha<0));...
                pNorm(Psit(out.alpha),1)];
            out.RMSE=sqrNorm(out.alpha-opt.trueAlpha)/sqrNorm(opt.trueAlpha);
            out.opt = opt;
            fprintf('fpcas cost=%g, RMSE=%g\n',out.f,out.RMSE);
        end
        function out = SPIRAL(Phi,Phit,Psi,Psit,y,xInit,opt)
            subtolerance=1e-5;
            if(~isfield(opt,'verbose')) opt.verbose=100; end
            [out.alpha, out.p, out.cost, out.reconerror, out.time,out.difAlpha] = ...
                SPIRALTAP_mod(y,Phi,opt.u,'penalty','ONB',...
                'AT',Phit,'W',Psi,'WT',Psit,'noisetype',opt.noiseType,...
                'initialization',xInit,'maxiter',opt.maxItr,...
                'miniter',0,'stopcriterion',3,...
                'tolerance',opt.thresh,'truth',opt.trueAlpha,...
                'subtolerance',subtolerance,'monotone',1,...
                'saveobjective',1,'savereconerror',1,'savecputime',1,...
                'reconerrortype',3,'savedifalpha',1,...
                'savesolutionpath',0,'verbose',opt.verbose);
            out.fVal=[0.5*sqrNorm(Phi(out.alpha)-y);...
                sqrNorm(out.alpha.*(out.alpha<0));...
                pNorm(Psit(out.alpha),1)];
            out.opt=opt;
            fprintf('SPIRAL cost=%g, RMSE=%g\n',out.cost(end),out.reconerror(end));
        end

        function out = SpaRSA(Phi,Phit,Psi,Psit,y,xInit,opt)
            fprintf('SpaRSA start\n');
            if(~isfield(opt,'verbose')) opt.verbose=true; end
            ppsi = @(xxx,uuu,thrsh) Psi(Utils.softThresh(Psit(xxx),uuu));
            rrrr = @(xxx) pNorm(Psit(xxx),1);
            [x_SpaRSA,x_debias_SpaRSA,obj_SpaRSA,times_SpaRSA,debias_start_SpaRSA,mse]=...
                SpaRSA_mod(y,Phi,opt.u,...
                'AT',Phit,...
                'Psi',ppsi,...
                'Phi',rrrr,...
                'Initialization',xInit,...
                'StopCriterion',5,...
                'ToleranceA',opt.thresh, ...
                'True_x',opt.trueAlpha,...
                'BB_variant',1,...
                'Safeguard',1,...
                'Monotone',0,...
                'Continuation',1,...
                'Verbose',opt.verbose,...
                'MaxiterA',opt.maxItr);
            clear('out');
            out.alpha=x_SpaRSA; out.cost=obj_SpaRSA; out.time=times_SpaRSA;
            out.RMSE=mse.mses/sqrNorm(opt.trueAlpha)*length(opt.trueAlpha);
            out.stepSize=mse.stepSize; out.difAlpha=mse.difAlpha;
            fprintf('SpaRSA cost=%g, RMSE=%g\n',out.cost(end),out.RMSE(end));
        end

        function out = SpaRSAp(Phi,Phit,Psi,Psit,y,xInit,opt)
            fprintf('SpaRSA nonnegative start\n');
            if(~isfield(opt,'verbose')) opt.verbose=true; end
            ppsi = @(xxx,uuu,thrsh) FISTA_ADMM_NNL1.innerADMM_v4(Psi,Psit,xxx,uuu,thrsh);
            rrrr = @(xxx) pNorm(Psit(xxx),1);
            [x_SpaRSA,x_debias_SpaRSA,obj_SpaRSA,times_SpaRSA,debias_start_SpaRSA,mse]=...
                SpaRSA_mod(y,Phi,opt.u,...
                'AT',Phit,...
                'Psi',ppsi,...
                'Phi',rrrr,...
                'Initialization',xInit,...
                'StopCriterion',5,...
                'ToleranceA',opt.thresh, ...
                'True_x',opt.trueAlpha,...
                'BB_variant',1,...
                'Safeguard',1,...
                'Monotone',0,...
                'Continuation',1,...
                'Verbose',opt.verbose,...
                'MaxiterA',opt.maxItr);
            clear('out');
            out.alpha=x_SpaRSA; out.cost=obj_SpaRSA; out.time=times_SpaRSA;
            out.RMSE=mse.mses/sqrNorm(opt.trueAlpha)*length(opt.trueAlpha);
            out.stepSize=mse.stepSize; out.difAlpha=mse.difAlpha;
            fprintf('SpaRSA nonnegative cost=%g, RMSE=%g\n',out.cost(end),out.RMSE(end));
        end
    end
end


